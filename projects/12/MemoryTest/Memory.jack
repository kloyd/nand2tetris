// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/12/Memory.jack

/**
 * This library provides two services: direct access to the computer's main
 * memory (RAM), and allocation and recycling of memory blocks. The Hack RAM
 * consists of 32,768 words, each holding a 16-bit binary number.
 */
class Memory {

    static Array ram;
    static Array heap;
    static int freeList;

    /** Initializes the class. */
    function void init() {
      let ram = 0;
      let heap = 2048; //heapBase
      let freeList = 2048;  // freelist - heap[freeList] is entry point to list.
      let heap[0] = 0;       // next freelist entry - 0 == end.
      let heap[1] = 14335;  // length of freelist entry
      return;
    }

    /** Returns the RAM value at the given address. */
    function int peek(int address) {
      return ram[address];
    }

    /** Sets the RAM value at the given address to the given value. */
    function void poke(int address, int value) {
      let ram[address] = value;
      return;
    }

    /** Finds an available RAM block of the given size and returns
     *  a reference to its base address. */
    function int alloc(int size) {
      var int findBase;
      var int foundSize;
      var int nextEntry;
      var int objectAddress;
      var int newHeapSize;
      var int totalAllocSize;

      let findBase = freeList;
      let totalAllocSize = size + 2;
      // Start with heap base = 2048
      let foundSize = ram[findBase + 1];
      let nextEntry = ram[findBase]; // actual ram address
      while ((size < (foundSize + 2)) & (~(nextEntry = 0))) {
          let findBase = nextEntry;  // actual ram address.
          let foundSize = ram[findBase + 1];
          let nextEntry = ram[findBase]; // actual ram address
      }
      if ( size < (foundSize + 2)) {
        // Block starts at findBase + foundSize + 2 (0 and 1 are for next/size entries)
        let objectAddress = (findBase + foundSize) - totalAllocSize;
        // reduce the freelist by size + 2
        let newHeapSize = foundSize - totalAllocSize;
        let ram[findBase + 1] = newHeapSize;
        // Set the size parameter for this block.
        let ram[objectAddress - 1] = size;
        // Set nextEntry to 0 (end of list)
        let ram[objectAddress - 2] = 0;
      } else {
        // negative 1 for fatal error... out of heap space.
        let objectAddress = -1;
      }
      return objectAddress;
    }

    /** De-allocates the given object (cast as an array) by making
     *  it available for future allocations. */
    function void deAlloc(Array o) {
      // o = blockAddr
      // o - 1 = size
      // o - 2 = nextEntry
      // find last entry.
      // add o memory to end of freelist.
      var int findBase;
      var int nextEntry;

      let findBase = freeList;
      let nextEntry = ram[findBase];
      while(~(nextEntry = 0)) {
        let findBase = nextEntry;
        let nextEntry = ram[nextEntry];
      }
      // findBase == Ram Address of end of list.
      let ram[findBase] = o - 2;
      return;
    }
}
